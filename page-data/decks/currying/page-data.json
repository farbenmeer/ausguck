{"componentChunkName":"component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js","path":"/decks/currying","matchPath":"/decks/currying/*","result":{"data":{"deck":{"id":"2ecf8c8d-eeb8-5893-ba14-6e9819040d9f","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = customTheme;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Head = makeShortcode(\"Head\");\nvar Image = makeShortcode(\"Image\");\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Head, {\n    mdxType: \"Head\"\n  }, mdx(\"title\", null, \"Currying\"), mdx(\"meta\", {\n    name: \"author\",\n    content: \"Max Str\\xFCbing\"\n  })), mdx(\"h1\", null, \"Currying!\"), mdx(\"p\", null, \"by Max Str\\xFCbing\\n(\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/mxstrbng\"\n  }), \"twitter\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/mstruebing\"\n  }), \"github\"), \")\"), mdx(\"hr\", null), mdx(\"p\", null, \"\\\"In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument.\\\"\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Currying\"\n  }), \"wikipedia.org/wiki/Currying\")), mdx(\"hr\", null), mdx(Image, {\n    src: haskellBCurry,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"small\", null, \"Haskell Curry\"), mdx(\"hr\", null), mdx(Image, {\n    src: haskellFunction,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"hr\", null), mdx(Image, {\n    src: haskellFunction,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"br\", null), mdx(Image, {\n    src: curriedFunction,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function add(a, b) {\\n    return a + b;\\n}\\n\")), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function add(a) {\\n    return function(b) {\\n        return a + b;\\n    }\\n}\\n\\n\")), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"add(1)(2); // 3\\n\")), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add1 = add(1);\\nadd1(2); // 3\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"With arrow functions\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add = (x, y) => x + y;\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"With arrow functions\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add = x => y => x + y;\\n\")), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add = (x, y) => x + y;\\n\")), mdx(Image, {\n    src: haskellFunction,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const add = x => y => x + y;\\n\")), mdx(Image, {\n    src: curriedFunction,\n    style: {\n      backgroundSize: 'auto'\n    },\n    mdxType: \"Image\"\n  }), mdx(\"hr\", null), mdx(\"p\", null, \"lodash.curry\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import {curry} from 'lodash.curry';\\n\\nconst abc = (a, b, c) => {\\n    return [a, b, c];\\n};\\n\\nconst curried = curry(abc);\\n\\ncurried(1)(2)(3);\\n// => [1, 2, 3]\\n\\ncurried(1, 2)(3);\\n// => [1, 2, 3]\\n\\ncurried(1, 2, 3);\\n// => [1, 2, 3]\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"If you apply the same arguments to a function more than once you should think if currying would be a good choice for you.\"), mdx(\"hr\", null), mdx(\"p\", null, \"Some languages that are curried by default: Haskell, Elm, OCaml, F# ...\"), mdx(\"hr\", null), mdx(\"p\", null, \"How does currying looks like in other languages?\"), mdx(\"hr\", null), mdx(\"p\", null, \"Go:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func add(x int) func(int) int {\\n    return func(y int) int {\\n        return x + y\\n    }\\n}\\n\\nfunc main() {\\n    fmt.Println(add(1)(2)) // 3\\n    add1 := add(1)\\n    fmt.Println(add1(2)) // 3\\n    fmt.Println(add1(3)) // 4\\n}\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"Haskell:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-hs\"\n  }), \"add x y  = x + y\\n\\nadd1 = add 1\\n\\nmain = do\\n    print $ add 1 2 -- 3\\n    print $ add1 2 -- 3\\n    print $ add1 3 -- 4\\n\")), mdx(\"hr\", null), mdx(\"p\", null, \"resources:\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://lodash.com/docs#curry\"\n  }), \"lodash.curry\")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Currying\"\n  }), \"wikipedia currying\")));\n}\n;\nMDXContent.isMDXComponent = true;","title":"Currying!"}},"pageContext":{"matchPath":"/decks/currying/*","id":"2ecf8c8d-eeb8-5893-ba14-6e9819040d9f","slug":"/ausguck/decks/currying","title":"Currying!"}},"staticQueryHashes":[]}