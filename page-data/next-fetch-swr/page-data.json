{
    "componentChunkName": "component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js",
    "path": "/next-fetch-swr",
    "result": {"data":{"deck":{"id":"c6f99d6d-c315-5ebf-98a6-db53fefacad2","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = customTheme;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Head = makeShortcode(\"Head\");\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Head, {\n    mdxType: \"Head\"\n  }, mdx(\"title\", null, \"E2E typings with next-fetch and SWR\"), mdx(\"meta\", {\n    name: \"author\",\n    content: \"Roman Ernst\"\n  })), mdx(\"h1\", null, \"E2E typings with next-fetch and SWR\"), mdx(\"p\", null, \"by Roman Ernst\\n(\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pex\"\n  }, \"github\"), \")\"), mdx(\"hr\", null), mdx(\"h1\", null, \"React-style fetching\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function SomeComponent() {\\n  const [data, setData] = useState<DataType>();\\n\\n  useEffect(() => {\\n    const fetcher = async () => {\\n      const data = await fetch(\\\"/api/data\\\");\\n      const json = (await data.json()) as DataType;\\n      setData(data);\\n    };\\n    fetcher();\\n  }, []);\\n\\n  return <div>{data ? data.name : \\\"Loading\\\"}</div>;\\n}\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Remember how types are applied here\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const [data, setData] = useState<DataType>();\\n// ...\\nconst json = (await data.json()) as DataType;\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"And what about errors?\"), mdx(\"hr\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const [error, setError] = useState<Error>()\\n\\ntry { ... } catch (error) {\\n  setError(error)\\n}\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"SWR to the rescue\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const fetcher = (...args) => fetch(...args).then((res) => res.json());\\n\\nfunction SomeComponent() {\\n  const { data, error } = useSWR(\\\"/api/data\\\", fetcher);\\n}\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Okay. But our types got lost!\"), mdx(\"hr\", null), mdx(\"h1\", null, \"SWR having a typed fetcher\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const fetcher: Fetcher<User, string> = (id) => getUserById(id);\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Somehow this feels odd \\uD83E\\uDD37\\u200D\\u2640\\uFE0F\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Where do types actully come from?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We know our data stucture from API routes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why do we have to handle them manually?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"So much boilerplate.\")), mdx(\"hr\", null), mdx(\"h1\", null, \"tRPC \\uD83E\\uDD18\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const { data } = trpc.greeting.useQuery();\\n\")), mdx(\"h2\", null, \"\\uD83D\\uDE0D\"), mdx(\"hr\", null), mdx(\"h1\", null, \"tRPC on the server\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { initTRPC } from \\\"@trpc/server\\\";\\nimport * as trpcNext from \\\"@trpc/server/adapters/next\\\";\\nimport { z } from \\\"zod\\\";\\n\\nconst t = initTRPC.create();\\n\\nconst appRouter = t.router({\\n  greeting: t.procedure\\n    .input(\\n      z.object({\\n        name: z.string().nullish(),\\n      })\\n    )\\n    .query(({ input }) => {\\n      return {\\n        text: `hello ${input?.name ?? \\\"world\\\"}`,\\n      };\\n    }),\\n});\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Router, Procedure, RPC? Rlly?\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Here comes next-fetch\"), mdx(\"h2\", null, \"Finally.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Next-fetch\"), mdx(\"h1\", null, \"The client\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const { data, error } = useData();\\n\")), mdx(\"h2\", null, \"\\uD83D\\uDE0D\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Next-fetch\"), mdx(\"h1\", null, \"The server\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const useData = query(async function () {\\n  return { some: \\\"data\\\" };\\n});\\n\")), mdx(\"h2\", null, \"\\uD83D\\uDE0D\"), mdx(\"hr\", null), mdx(\"h1\", null, \"You forgot the types! \\uD83D\\uDE48\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Types are imported alongside the hook\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { useData } from \\\"/api/data.swr\\\";\\n\")), mdx(\"p\", null, \"is fully typed! And this test will succeeed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type test = Expect<Equal<data, { some: string }>>;\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"That easy?\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Yes.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Background note\"), \": this is done by compiling files with an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swr.ts\"), \" ending to custom API routes.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"I see \\uD83D\\uDC4C\"), mdx(\"h1\", null, \"How about passing arguments?\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Easy.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Client\\nconst { data, error } = useData({ foo: \\\"bar\\\" });\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Server\\nexport const useData = query(\\n  z.object({ foo: z.string() }),\\n  async function ({ foo }) {\\n    return { some: foo }; // foo is now guaranteed to be a typeof string\\n  }\\n);\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Does this also work for mutations?\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Sure.\"), mdx(\"h1\", null, \"Mutations look very similar:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const useCreateData = mutation(\\n  z.object({ foo: z.string() }),\\n  async function ({ foo }) {\\n    // ... do some DB operations ...\\n    return { some: foo };\\n  }\\n);\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Mutations on the client\"), mdx(\"h2\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"next-fetch/Form\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const createData = useCreateData();\\n\\nreturn (\\n  <Form mutation={createData}>\\n    <input type=\\\"text\\\" name=\\\"some\\\" />\\n  </Form>\\n);\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Mutations on the client\"), mdx(\"h2\", null, \"Using trigger\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const createData = useCreateData();\\n\\nreturn <button onClick={() => createData.trigger({ some: \\\"data\\\" })} />;\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Looks nice!\"), mdx(\"h1\", null, \"Though this is not very optistic.\"), mdx(\"hr\", null), mdx(\"h1\", null, \"Optimistic updates at your findertips\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"function DataList() {\\n  const { data, mutate } = useData();\\n  const createData = useCreateData();\\n\\n  function handleButtonClick() {\\n    const data = { some: \\\"data\\\" };\\n    createData.trigger(data); // We could also `await` this\\n    mutate([...data, data]); // Optimistic update\\n  }\\n\\n  return (\\n    <>\\n      <ul>\\n        {data.list.map((item) => (\\n          <li key={item.id}>{item.name}</li>\\n        ))}\\n      </ul>\\n      <button onClick={handleButtonClick} />\\n    </>\\n  );\\n}\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"Check it out:\"), mdx(\"p\", null, \"\\uD83D\\uDC19\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/vercel-labs/next-fetch/\"\n  }, \"https://github.com/vercel-labs/next-fetch/\")), mdx(\"h1\", null, \"Questions\"), mdx(\"h2\", null, \"\\uD83D\\uDE4B\\u200D\\u2640\\uFE0F\"));\n}\n;\nMDXContent.isMDXComponent = true;","title":"E2E typings with next-fetch and SWR"}},"pageContext":{"matchPath":"/next-fetch-swr/*","id":"c6f99d6d-c315-5ebf-98a6-db53fefacad2","slug":"/ausguck/next-fetch-swr","title":"E2E typings with next-fetch and SWR"}},
    "staticQueryHashes": [],
    "matchPath": "/next-fetch-swr/*"}